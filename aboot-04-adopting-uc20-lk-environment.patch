From ac63fa6a50a708c85344ab07f0da3eb3c18bc2b4 Mon Sep 17 00:00:00 2001
From: Ondrej Kubik <ondrej.kubik@canonical.com>
Date: Fri, 23 Oct 2020 15:55:45 +0100
Subject: [PATCH] ubuntu: adopting uc20 lk environment and boot sequence

Signed-off-by: Ondrej Kubik <ondrej.kubik@canonical.com>
---
 app/aboot/aboot.c       |   1 +
 app/aboot/snappy_boot.c | 352 +++++++++++++++++++++++++---------------
 app/aboot/snappy_boot.h |   2 +-
 3 files changed, 219 insertions(+), 136 deletions(-)

diff --git a/app/aboot/aboot.c b/app/aboot/aboot.c
index b285f40b..7935c783 100644
--- a/app/aboot/aboot.c
+++ b/app/aboot/aboot.c
@@ -1108,6 +1108,7 @@ int boot_linux_from_mmc(void)
 			dprintf(INFO, "snappy: controlled boot partition[%s]\n", bootpart);
 			dprintf(INFO, "snappy: cmdline[%s]\n", snappy_cmdline);
 			index = partition_get_index(bootpart);
+			ptn = partition_get_offset(index);
 		}
 		else
 #endif
diff --git a/app/aboot/snappy_boot.c b/app/aboot/snappy_boot.c
index 88314f46..6aaf528a 100644
--- a/app/aboot/snappy_boot.c
+++ b/app/aboot/snappy_boot.c
@@ -43,9 +43,6 @@
 static char cmdline_buf[512];
 static char bootpart_buf[SNAP_NAME_MAX_LEN];
 
-const char* Snap_Permited_Reboot_Reasons[] = {"backup-serial", "restore-serial"};
-#define SNAP_NUM_OF_REBOOT_REASONS 2
-
 static uint32_t crc32(uint32_t crc, unsigned char *buf, size_t len)
 {
     int k;
@@ -60,121 +57,101 @@ static uint32_t crc32(uint32_t crc, unsigned char *buf, size_t len)
 }
 
 
-static int map_bootimg(const SNAP_BOOT_SELECTION_t *boot_select, const char *snap_kernel);
-static SNAP_BOOT_SELECTION_t *load_environment();
-static int save_environment(SNAP_BOOT_SELECTION_t *boot_select);
-static SNAP_BOOT_SELECTION_t *load_environment_from_part(const char *partName);
-static int save_environment_to_part(SNAP_BOOT_SELECTION_t *boot_select,
-                                           const char *partName);
+static int map_bootimg(size_t rows,
+                       const char *snap_kernel,
+                       char bootimg_matrix[][2][SNAP_NAME_MAX_LEN]);
+static SNAP_RUN_BOOT_SELECTION_t *load_run_environment();
+static SNAP_RECOVERY_BOOT_SELECTION_t *load_recovery_environment();
+static int save_run_environment(SNAP_RUN_BOOT_SELECTION_t *boot_select);
+static int save_recovery_environment(SNAP_RECOVERY_BOOT_SELECTION_t *recovery_select);
+static SNAP_RUN_BOOT_SELECTION_t *load_run_environment_from_part(const char *partName);
+static SNAP_RECOVERY_BOOT_SELECTION_t *load_recovery_environment_from_part(const char *partName);
+static void *load_environment_from_part(uint32_t env_size, const char *partName);
+static int save_environment_to_part( void *env, uint32_t data_len, const char *partName);
 static int StringLenClean(const char *string);
 
 void snap_get_target_boot_params(const char **bootpart, const char **cmdline)
 {
-    char *snap_core, *snap_kernel;
-    char reboot_reason[50] = {'\0'};
-    SNAP_BOOT_SELECTION_t *boot_select = load_environment();
-    int i;
+    char *snap_kernel = NULL;
+    char *recovery_mode = NULL;
+    SNAP_RUN_BOOT_SELECTION_t *boot_select = NULL;
+    SNAP_RECOVERY_BOOT_SELECTION_t *recovery_select = load_recovery_environment();
+
+    if (recovery_select == NULL){
+        dprintf(CRITICAL, "snap: missing recovery environment!\n");
+        return;
+    }
+
+    // recovery mode can be unset, in which case "install" should be assumed
+    if (strlen(recovery_select->snapd_recovery_mode)) {
+        recovery_mode = recovery_select->snapd_recovery_mode;
+    } else {
+        recovery_mode = SNAP_RECOVERY_MODE_INSTALL;
+    }
+    if ( strncmp(recovery_mode, SNAP_RECOVERY_MODE_RUN, SNAP_NAME_MAX_LEN)) {
+        dprintf(INFO, "snap: get boot params: detected %s mode\n", recovery_mode );
+        snprintf(cmdline_buf,
+                 sizeof(cmdline_buf),
+                 " snapd_recovery_mode=%s snapd_recovery_system=%s dangerous",
+                 recovery_mode,
+                 recovery_select->snapd_recovery_system);
+
+        // map recovery system to boot partition
+        map_bootimg(SNAP_RECOVERY_BOOTIMG_PART_NUM,
+                    recovery_select->snapd_recovery_system,
+                    recovery_select->bootimg_matrix);
+        *cmdline = cmdline_buf;
+        *bootpart = bootpart_buf;
+        // cleanup and boot recovery
+        goto cleanup;
+    }
+
+    snprintf(cmdline_buf,
+                 sizeof(cmdline_buf),
+                 " snapd_recovery_mode=%s dangerous",
+                 recovery_mode);
+
 
+    // load run time environment to handle run time case
+    boot_select = load_run_environment();
     if (boot_select == NULL)
         return;
 
-    snap_core = boot_select->snap_core;
     snap_kernel = boot_select->snap_kernel;
-    if ( !strncmp(boot_select->snap_mode, SNAP_MODE_TRY, SNAP_NAME_MAX_LEN)) {
-        strncpy(boot_select->snap_mode, SNAP_MODE_TRYING, SNAP_NAME_MAX_LEN);
-        if (save_environment(boot_select))
+    if ( !strncmp(boot_select->kernel_status, SNAP_MODE_TRY, SNAP_NAME_MAX_LEN)) {
+        strncpy(boot_select->kernel_status, SNAP_MODE_TRYING, SNAP_NAME_MAX_LEN);
+        if (save_run_environment(boot_select))
             goto cleanup;
-        if ( strlen(boot_select->snap_try_core)) {
-            snap_core = boot_select->snap_try_core;
-        }
         if (strlen( boot_select->snap_try_kernel)) {
             snap_kernel = boot_select->snap_try_kernel;
         }
-    } else if ( !strncmp(boot_select->snap_mode, SNAP_MODE_TRYING, SNAP_NAME_MAX_LEN)) {
-        boot_select->snap_mode[0] = 0;
-        if (save_environment(boot_select))
+    } else if ( !strncmp(boot_select->kernel_status, SNAP_MODE_TRYING, SNAP_NAME_MAX_LEN)) {
+        boot_select->kernel_status[0] = 0;
+        if (save_run_environment(boot_select))
             goto cleanup;
     }
 
-    // update boot reason
-    // factory-reset: keep environment value to handle incomplete factory-reset
-    //                if all succeeds new environment is restored from backup
-    // other reboot reason: verify is permitted, clear value
-    // only proceed if there is reboot reason value
-    if (strlen(boot_select->reboot_reason)) {
-        if ( !strncmp(boot_select->reboot_reason,
-                      FACTORY_RESET,
-                      strlen(FACTORY_RESET))) {
-            dprintf(INFO, "snap: Factory reset reboot reason [%s]\n",
-                                                 boot_select->reboot_reason);
-            strncpy(reboot_reason,
-                    boot_select->reboot_reason,
-                    StringLenClean (boot_select->reboot_reason));
-        } else {
-            for (i=0; i < SNAP_NUM_OF_REBOOT_REASONS; ++i) {
-                if ( !strncmp(boot_select->reboot_reason,
-                              Snap_Permited_Reboot_Reasons[i],
-                              strlen(Snap_Permited_Reboot_Reasons[i]))
-                   ) {
-                    dprintf(INFO, "snap: Updating reboot reason [%s]\n",
-                                        boot_select->reboot_reason);
-                    strncpy(reboot_reason,
-                            boot_select->reboot_reason,
-                            StringLenClean (boot_select->reboot_reason));
-                    // clearing reboot reason
-                    boot_select->reboot_reason[0] = 0;
-                    // ignore error for clearing reboot reason
-                    save_environment(boot_select);
-                    break;
-                }
-            }
-        }
-    }
-    map_bootimg(boot_select, snap_kernel);
-    if (strlen(reboot_reason)) {
-        snprintf(cmdline_buf,
-                 sizeof(cmdline_buf),
-                 " snap_core=%s snap_kernel=%s %s ",
-                 snap_core,
-                 snap_kernel,
-                 reboot_reason);
-    } else {
-        snprintf(cmdline_buf,
-                 sizeof(cmdline_buf),
-                 " snap_core=%s snap_kernel=%s ",
-                 snap_core,
-                 snap_kernel);
-    }
+    map_bootimg(SNAP_RUN_BOOTIMG_PART_NUM, snap_kernel, boot_select->bootimg_matrix);
     *cmdline = cmdline_buf;
     *bootpart = bootpart_buf;
 
     cleanup:
+        if(recovery_select)
+            free(recovery_select);
         if(boot_select)
             free(boot_select);
 }
 
-int map_bootimg(const SNAP_BOOT_SELECTION_t *boot_select, const char *snap_kernel)
+static int map_bootimg(size_t rows,
+                const char *snap_kernel,
+                char bootimg_matrix[][2][SNAP_NAME_MAX_LEN])
 {
-    // BootReason takes over normal boot
-    // for UC18, this hardcoded case of boot_recovery for factory reset case
-    if  ( !strncmp(boot_select->reboot_reason,
-                   FACTORY_RESET,
-                   strlen(FACTORY_RESET))) {
-          if (strlen(boot_select->unused_key_01)) {
-              // we need only slot part of partition table ( '_a' or '_b')
-              strncpy(bootpart_buf, boot_select->unused_key_01, SNAP_NAME_MAX_LEN);
-              return 0;
-          } else {
-              strncpy(bootpart_buf,"boot_r", SNAP_NAME_MAX_LEN);
-              return 0;
-          }
-    }
-    for (size_t n = 0; n < SNAP_BOOTIMG_PART_NUM; ++n) {
-        if (!strncmp(boot_select->bootimg_matrix[n][1],
+    for (size_t n = 0; n < rows; ++n) {
+        if (!strncmp(bootimg_matrix[n][1],
             snap_kernel,
             SNAP_NAME_MAX_LEN)) {
-            if (strlen(boot_select->bootimg_matrix[n][0])) {
-                strncpy(bootpart_buf, boot_select->bootimg_matrix[n][0], SNAP_NAME_MAX_LEN);
+            if (strlen(bootimg_matrix[n][0])) {
+                strncpy(bootpart_buf, bootimg_matrix[n][0], SNAP_NAME_MAX_LEN);
                 return 0;
             }
         }
@@ -183,106 +160,211 @@ int map_bootimg(const SNAP_BOOT_SELECTION_t *boot_select, const char *snap_kerne
     return -1;
 }
 
-// try to load backup env if main fails
-static SNAP_BOOT_SELECTION_t *load_environment()
+// load runtime environment, try to load backup env if main fails
+static SNAP_RUN_BOOT_SELECTION_t *load_run_environment()
 {
-    SNAP_BOOT_SELECTION_t *boot_select = load_environment_from_part(SNAP_BOOTSELECT_PARTITION);
+    SNAP_RUN_BOOT_SELECTION_t *boot_select = load_run_environment_from_part(SNAP_BOOTSELECT_PARTITION);
     if (boot_select == NULL) {
-        boot_select = load_environment_from_part(SNAP_BOOTSELECT_PARTITION "bak");
+        boot_select = load_run_environment_from_part(SNAP_BOOTSELECT_PARTITION "bak");
         // if we successfully loaded backup env, try to save it to main, ignore error
-        if (boot_select)
-            save_environment_to_part( boot_select, SNAP_BOOTSELECT_PARTITION);
+        if (boot_select) {
+            // restore primary environment
+            uint32_t block_size = mmc_get_device_blocksize();
+            uint32_t data_len = ROUNDUP(sizeof(SNAP_RUN_BOOT_SELECTION_t), block_size);
+            save_environment_to_part( (void *)boot_select, data_len, SNAP_BOOTSELECT_PARTITION);
+        }
     }
     return boot_select;
 }
 
-// save always to main and backup env
-static int save_environment(SNAP_BOOT_SELECTION_t *boot_select)
+// load recovery environment, try to load backup env if main fails
+static SNAP_RECOVERY_BOOT_SELECTION_t *load_recovery_environment()
+{
+  SNAP_RECOVERY_BOOT_SELECTION_t *recovery_select = load_recovery_environment_from_part(SNAP_RECOVERYSELECT_PARTITION);
+  if (recovery_select == NULL) {
+      recovery_select = load_recovery_environment_from_part(SNAP_RECOVERYSELECT_PARTITION "bak");
+      // if we successfully loaded backup env, try to save it to main, ignore error
+      if (recovery_select) {
+          // restore primary environment
+          uint32_t block_size = mmc_get_device_blocksize();
+          uint32_t data_len = ROUNDUP(sizeof(SNAP_RUN_BOOT_SELECTION_t), block_size);
+          save_environment_to_part( (void *)recovery_select, data_len, SNAP_RECOVERYSELECT_PARTITION);
+      }
+  }
+  return recovery_select;
+}
+
+// save runtime environment always to main and backup env
+static int save_run_environment(SNAP_RUN_BOOT_SELECTION_t *boot_select)
 {
+    uint32_t block_size = mmc_get_device_blocksize();
+    uint32_t data_len = ROUNDUP(sizeof(SNAP_RUN_BOOT_SELECTION_t), block_size);
+    // first calculate crc32 for the passed boot selection
+    boot_select->crc32 = crc32( 0,
+                        (unsigned char *)boot_select,
+                        sizeof(SNAP_RUN_BOOT_SELECTION_t)-sizeof(uint32_t));
     // if at least one write works, return success, use two variables, that compiler
     // does not optimise
-    int r = save_environment_to_part( boot_select, SNAP_BOOTSELECT_PARTITION);
-    int rb = save_environment_to_part( boot_select, SNAP_BOOTSELECT_PARTITION "bak");
+    int r = save_environment_to_part( (void *)boot_select,
+                                      data_len,
+                                      SNAP_BOOTSELECT_PARTITION);
+    int rb = save_environment_to_part( (void *)boot_select,
+                                      data_len,
+                                      SNAP_BOOTSELECT_PARTITION "bak");
     return r & rb;
 }
 
-static SNAP_BOOT_SELECTION_t *load_environment_from_part(const char *partName)
+// save recovery environment always to main and backup env
+static int save_recovery_environment(SNAP_RECOVERY_BOOT_SELECTION_t *recovery_select)
+{
+    uint32_t block_size = mmc_get_device_blocksize();
+    uint32_t data_len = ROUNDUP(sizeof(SNAP_RECOVERY_BOOT_SELECTION_t), block_size);
+    // first calculate crc32 for the passed boot selection
+    recovery_select->crc32 = crc32( 0,
+                      (unsigned char *)recovery_select,
+                      sizeof(SNAP_RECOVERY_BOOT_SELECTION_t)-sizeof(uint32_t));
+
+    // if at least one write works, return success, use two variables, that compiler
+    // does not optimise
+    int r = save_environment_to_part( (void *)recovery_select,
+                                      data_len,
+                                      SNAP_RECOVERYSELECT_PARTITION);
+    int rb = save_environment_to_part( (void *)recovery_select,
+                                      data_len,
+                                      SNAP_RECOVERYSELECT_PARTITION "bak");
+    return r & rb;
+}
+
+static SNAP_RUN_BOOT_SELECTION_t *load_run_environment_from_part(const char *partName)
 {
-    unsigned long long ptn = 0;
     uint32_t block_size = mmc_get_device_blocksize();
     uint32_t actual_struct_size, crc;
-    SNAP_BOOT_SELECTION_t *boot_select = NULL;
-    int index = INVALID_PTN;
-    index = partition_get_index(partName);
-    ptn = partition_get_offset(index);
+    SNAP_RUN_BOOT_SELECTION_t *boot_select = NULL;
 
-    if(ptn == 0)
+    actual_struct_size = ROUNDUP(sizeof(SNAP_RUN_BOOT_SELECTION_t), block_size);
+    boot_select = load_environment_from_part(actual_struct_size, partName);
+    if (boot_select == NULL)
     {
-        dprintf(CRITICAL, "snap: load_environment: ERROR: No %s partition found\n", partName);
+        dprintf(CRITICAL, "snap: load_run_environment: Failed to load env from storage\n");
+        return NULL;
+    }
+
+    dprintf(SPEW, "snap: load_run_environment(%s): read SNAP_RUN_BOOT_SELECTION: SUCCESS, read %d bytes\n", partName, actual_struct_size);
+    crc = crc32( 0, (unsigned char *)boot_select, sizeof(SNAP_RUN_BOOT_SELECTION_t)-sizeof(uint32_t));
+    if ( boot_select->version != SNAP_BOOTSELECT_VERSION_V2 || boot_select->signature != SNAP_BOOTSELECT_SIGNATURE_RUN )
+    {
+        dprintf(CRITICAL, "snap: load_run_environment(%s): ERROR version/signature broken [0x%X] vs [0x%X], [0x%X] vs [0x%X]!\n",
+            partName, boot_select->version, SNAP_BOOTSELECT_VERSION_V2, boot_select->signature, SNAP_BOOTSELECT_SIGNATURE_RUN);
+        goto cleanup;
+    }
+    if ( boot_select->crc32 != crc )
+    {
+        dprintf(CRITICAL, "snap: load_run_environment(%s): ERROR crc32 broken [0x%X] vs [0x%X]!\n", partName, boot_select->crc32, crc );
         goto cleanup;
+    } else {
+        dprintf(INFO, "snap: load_run_environment(%s): crc32 sucessfully validated\n", partName );
     }
+    return boot_select;
 
-    actual_struct_size = ROUNDUP(sizeof(SNAP_BOOT_SELECTION_t), block_size);
-    boot_select = malloc(actual_struct_size);
-    if (boot_select == NULL)
+    cleanup:
+        if(boot_select)
+            free(boot_select);
+        return NULL;
+}
+
+static SNAP_RECOVERY_BOOT_SELECTION_t *load_recovery_environment_from_part(const char *partName)
+{
+    uint32_t block_size = mmc_get_device_blocksize();
+    uint32_t actual_struct_size, crc;
+    SNAP_RECOVERY_BOOT_SELECTION_t *recovery_select = NULL;
+
+    actual_struct_size = ROUNDUP(sizeof(SNAP_RECOVERY_BOOT_SELECTION_t), block_size);
+    recovery_select = load_environment_from_part(actual_struct_size, partName);
+    if (recovery_select == NULL)
+    {
+        dprintf(CRITICAL, "snap: load_recovery_environment: Failed to load env from storage\n");
+        return NULL;
+    }
+
+    dprintf(SPEW, "snap: load_recovery_environment(%s): read SNAP_RECOVERY_BOOT_SELECTION: SUCCESS, read %d bytes\n", partName, actual_struct_size);
+    crc = crc32( 0, (unsigned char *)recovery_select, sizeof(SNAP_RECOVERY_BOOT_SELECTION_t)-sizeof(uint32_t));
+    if ( recovery_select->version != SNAP_BOOTSELECT_VERSION_V2 || recovery_select->signature != SNAP_BOOTSELECT_SIGNATURE_RECOVERY )
+    {
+        dprintf(CRITICAL, "snap: load_recovery_environment(%s): ERROR version/signature broken [0x%X] vs [0x%X], [0x%X] vs [0x%X]!\n",
+            partName, recovery_select->version, SNAP_BOOTSELECT_VERSION_V2, recovery_select->signature, SNAP_BOOTSELECT_SIGNATURE_RECOVERY);
+        goto cleanup;
+    }
+    if ( recovery_select->crc32 != crc )
     {
-        dprintf(CRITICAL, "snap: load_environment: ERROR, cannot allocate SNAP_BOOT_SELECTION\n");
+        dprintf(CRITICAL, "snap: load_recovery_environment(%s): ERROR crc32 broken [0x%X] vs [0x%X]!\n", partName, recovery_select->crc32, crc );
         goto cleanup;
+    } else {
+        dprintf(INFO, "snap: load_recovery_environment(%s): crc32 sucessfully validated\n", partName );
     }
+    return recovery_select;
 
-    mmc_set_lun(partition_get_lun(index));
-    if(mmc_read(ptn, (void *)boot_select, actual_struct_size))
+    cleanup:
+        if(recovery_select)
+            free(recovery_select);
+        return NULL;
+}
+
+static void *load_environment_from_part(uint32_t env_size, const char *partName)
+{
+    unsigned long long ptn = 0;
+    void *env_buf = NULL;
+    int index = INVALID_PTN;
+    index = partition_get_index(partName);
+    ptn = partition_get_offset(index);
+
+    if(ptn == 0)
     {
-        dprintf(CRITICAL, "snap: load_environment(%s): read SNAP_BOOT_SELECTION: ERROR, cannot read Snap boot select info\n", partName);
+        dprintf(CRITICAL, "snap: load_environment_from_part: ERROR: No [%s] partition found\n", partName);
         goto cleanup;
     }
 
-    dprintf(SPEW, "snap: load_environment(%s): read SNAP_BOOT_SELECTION: SUCCESS, read %d bytes\n", partName, actual_struct_size);
-    crc = crc32( 0, (unsigned char *)boot_select, sizeof(SNAP_BOOT_SELECTION_t)-sizeof(uint32_t));
-    if ( boot_select->version != SNAP_BOOTSELECT_VERSION || boot_select->signature != SNAP_BOOTSELECT_SIGNATURE )
+    env_buf = malloc(env_size);
+    if (env_buf == NULL)
     {
-        dprintf(CRITICAL, "snap: load_environment(%s): ERROR version/signature broken [0x%X] vs [0x%X], [0x%X] vs [0x%X]!\n",
-            partName, boot_select->version, SNAP_BOOTSELECT_VERSION, boot_select->signature, SNAP_BOOTSELECT_SIGNATURE);
+        dprintf(CRITICAL, "snap: load_environment_from_part: ERROR, cannot allocate env buffer\n");
         goto cleanup;
     }
-    if ( boot_select->crc32 != crc )
+
+    mmc_set_lun(partition_get_lun(index));
+    if(mmc_read(ptn, env_buf, env_size))
     {
-        dprintf(CRITICAL, "snap: load_environment(%s): ERROR crc32 broken [0x%X] vs [0x%X]!\n", partName, boot_select->crc32, crc );
+        dprintf(CRITICAL, "snap: load_environment_from_part(%s): read environment: ERROR, cannot read Snap select env info\n", partName);
         goto cleanup;
-    } else {
-        dprintf(INFO, "snap: load_environment(%s): crc32 sucessfully validated\n", partName );
     }
-    return boot_select;
+    return env_buf;
 
     cleanup:
-        if(boot_select)
-            free(boot_select);
+        if(env_buf)
+            free(env_buf);
         return NULL;
 }
 
-static int save_environment_to_part( SNAP_BOOT_SELECTION_t *boot_select, const char *partName)
+static int save_environment_to_part( void *env, uint32_t data_len, const char *partName)
 {
     unsigned long long ptn = 0;
-    uint32_t block_size = mmc_get_device_blocksize();
 
     int index = INVALID_PTN;
 
-    ASSERT(boot_select != NULL);
-    boot_select->crc32 = crc32( 0, (unsigned char *)boot_select, sizeof(SNAP_BOOT_SELECTION_t)-sizeof(uint32_t));
+    ASSERT(env != NULL);
 
     index = partition_get_index(partName);
     ptn = partition_get_offset(index);
 
     if(ptn == 0)
     {
-        dprintf(CRITICAL, "snap: save_environment: ERROR: No %s partition found\n", partName);
+        dprintf(CRITICAL, "snap: save_environment_to_part: ERROR: No %s partition found\n", partName);
         return -1;
     }
 
     mmc_set_lun(partition_get_lun(index));
-    if(mmc_write(ptn, ROUNDUP(sizeof(SNAP_BOOT_SELECTION_t), block_size), (void *)boot_select))
+    if(mmc_write(ptn, data_len, env))
     {
-        dprintf(CRITICAL, "snap: save_environment: ERROR, cannot write SNAP_BOOTSELECT info\n");
+        dprintf(CRITICAL, "snap: save_environment_to_part: ERROR, cannot write env\n");
         return -1;
     }
     return 0;
diff --git a/app/aboot/snappy_boot.h b/app/aboot/snappy_boot.h
index 4d96b93c..2f5b4674 100644
--- a/app/aboot/snappy_boot.h
+++ b/app/aboot/snappy_boot.h
@@ -18,7 +18,7 @@
 #ifndef _BOOTLOADER_SNAP_BOOT_H
 #define _BOOTLOADER_SNAP_BOOT_H
 
-#include "snappy_boot_v1.h"
+#include "snappy_boot_v2.h"
 
 void snap_get_target_boot_params(const char **bootpart, const char **cmdline);
 
-- 
2.26.2

